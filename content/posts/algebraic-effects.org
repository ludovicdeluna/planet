#+BEGIN_QUOTE
La programmation fonctionnelle pure offre beaucoup de bénéfices. Elle n'utilise
que des fonctions pures qui sont faciles à tester, facile à raisonner et 
qui permettent au compilateur de les optimiser.

Ce serait vraiment plus confortable de ne travailler qu'avec des fonctions pures,
malheureusement, dans la construction de logiciels "utiles", cela semble 
impossible. En effet *les programmes du monde réel produisent des effets*, il 
est donc, à priori, impossible de représenter un programme utile à coup de 
fonctions pures.

Dans ce très court article, je vous propose de découvrir *les effets algébriques* 
*et leurs gestionnaires* pour construire des programmes qui exécutent des 
effets, dans le contexte d'un langage de programmation fonctionnel, 
que l'on peut composer (pour construire des programmes plus complexes) tout 
en restant facilement testable unitairement.

Cet article n'est pas du tout un article technique et son objectif vise
à donner une intution sur l'utilisation des effets algébriques. Il ne va
volontairement pas très loin dans l'exercice de la construction d'un 
système d'effets (j'en suis malheureusement incapable). Si vous êtes
familiers avec la gestion des effets dans un langage de programmation,
il y a fort à partier que cet article ne vous intéresse pas beaucoup... désolé !
#+END_QUOTE

Cela fait très longtemps que l'importance des tests unitaires n'est plus 
remise en question. Ils permettent de garantir, au mieux, la non-régression
de la base de code, mais aussi servir de spécification. Couplé avec des méthodes
fines, comme par exemple, les tests dirigés par les propriétés, qui, sur base
d'une collection d'invariants (les propriétés), génèrent une collection de
tests "aléatoirement". Il est donc nécéssaire de fournir un maximum de tests,
clairs et facilement maintenable.

Concrètement, il est possible de facilement tester unitairement les *fonctions*
*pures*, alors que les *fonctions impures* infligent généralement l'usage de
/hacks/ pour capturer l'essence de la fonctionnalité testée.


** Fonctions pures et impures

Dans un premier temps, observons cette fonction, implémentée en *Kotlin*, dont
le rôle principal est de calculer le successeur d'un nombre :

#+BEGIN_SRC kotlin :data-roe-kind code :data-pellet Kotlin :data-line-number true
import java.util.Scanner

fun successor() {
  val reader = Scanner(System.`in`)
  print("Enter a number: ")
  val input = reader.nextInt()
  val result = input + 1
  println("The successor of [$input] is [$result] ")
}

fun main() {
  successor()
}
#+END_SRC

Concrètement, cette fonction est potentiellement correct, cependant, elle pose,
selon moi (et selon beaucoup de personne, probablement) énormément de soucis.
Elle est impossible à tester unitairement facilement. En admettant que je
voudrais tester cette fonction, je devrais capturer l'écriture sur 
src_bash{stdin} et l'écriture sur src_bash{stdout} pour être capable de fournir
une collection de tests sur l'essence de mon algorithme, soit le fait que 
pour un nombre entier, je peux avoir son successeur. La fonction n'est pas pure,
donc complexe à tester.

Une piste d'amélioration serait d'extraire l'essence du programme dans une
fonction dédiée, dont le seul rôle serait de calculer le successeur d'un nombre
entier. Par exemple : 

#+BEGIN_SRC kotlin :data-roe-kind code :data-pellet Kotlin :data-line-number true
import java.util.Scanner

fun successor(x: Int) : Int {
  val result = x + 1
  return result
}

fun main() {
  val reader = Scanner(System.`in`)
  print("Enter a number: ")
  val input = reader.nextInt()
  val result = successor(input)
  println("The successor of [$input] is [$result] ")
}
#+END_SRC

Cette amélioration est très naïve, mais elle représente tout de même une sacré
pas en avant. La fonction src_kotlin{successor(x)} est facilement testable,
et ça tombe assez bien, car c'est elle qui est le coeur de notre programme.

Même s'il serait possible d'écrire un test unitaire pour la fonction 
src_kotlin{main()} moyennant quelques tours de magie... est-ce réellement 
nécéssaire ? En effet, comme évoqué précédemment, l'essence de notre 
(discutablement intéressant) programme est de calculer un successeur pour un 
entier donné, et cette partie du programme est correctement testée, le reste
du programme ne fait qu'exploiter des bibliothèques et des fonctions éprouvées
de la /JVM/ et, à l'instar des démonstrations mathématiques, qui visent à
réduire une collection de propositions à des axiomes, on ne cherche pas à 
tester ce qui a déjà été testé.

Mais tout ceci nous amène à une chose, depuis le début de cet article, j'utilise
les adjectifs *pure* et *impure* pour qualifier les fonctions, sans avoir pris
le temps de tâcher de fournir une définition compréhensible de fonctions pures 
et impures ! Concrètement, dès que l'on parle de fonctions pures, on entend
généralement des fonctions *dans le sens mathématique du terme*, soit des
fonctions qui sont : 

- *totales* : pour chaque entrée, elles produisent un résultat. (Doté d'un
  système de vérification statique des types, il est possible de restreindre
  le domaine de valeurs acceptées par une fonction) ;
- *déterministes* : pour des arguments donnés à une fonction, elle renvoie
  toujours le même résultat ;
- *sans effets* : elles ne produisent aucun effet. Elle ne peuvent que
  calculer des choses, sans dépendre, par exemple d'un environnement. Dans
  la partie suivante, nous tâcherons de donner une meilleur définition
  d'effets.

Ce que l'on pourrait réduire en une phrase, une fonction pure est une
fonction qui retourne constamment la même valeur pour la même entrée,
mettant en lumière un comportement déterministe et ne provoquant aucun
effet extérieur. Une fonction pure est *référentiellement transparente*,
ce qui veut dire que l'on peut remplacer chacun de ses appels par son
résultat, dès qu'on le connait.

Les fonctions impures sont toutes les fonctions qui ne sont pas pures. 
Comme évoqué rapidement en introduction, sans fonctions impures, il est 
à priori impossible de faire un programme utile. En effet, à moins que
l'exécution du programme ne soit pas nécéssaire (par exemple lorsque l'on
utilise un logiciel de démonstration assisté par ordinateur), construire
un programme sans fonctions impures, donc sans effets, semble impossible.

Une première approche pour rendre nos logiciels testables et prédictibles
consiste à fractionner le programme en *deux parties*, sa partie pure 
et sa partie impure. Idéalement, repoussant les fragments impures aux 
extrémités du programme (ses entrées et ses sorties) pour n'avoir ensuite, 
plus qu'un noyau de fonctions pures, facilement testables. 


** Effets et effets de bords

Comme une grande partie des langages de programmation populaires 
manipulent des effets de manière implicite, s'interroger sur ce qu'est
un effet peut être assez peu commode. D'ailleurs, je trouve qu'il est
assez complexe de donner une définition acceptable et claire d'un effet,
généralement, on trouve des exemples d'effets :

- du non déterminisme ;
- le fait de lire un environnement (une base de données par exemple) ;
- le fait de modifier cet environnement ;
- de l'aléatoire ;
- etc.

Une manière assez /simple/ de caractériser un effet serait de l'opposer
à un calcul. Dans la programmation fonctionnelle pure, l'exécution d'un
programme (sans effets donc) consiste "simplement" à calculer sa 
*forme normale*, soit son résultat final, un effet serait donc quelque chose
que l'on peut pas calculer. 

Pour donner plus de précision, il s'agirait
de définir un effet comme une action qui a besoin d'être exécutée en
*référant une autorité centrale qui devra /gérer/ cet effet*. Par exemple,
un programme qui lance une exception implique que cette exception soit
gérée (via une construction, par exemple, en Java, src_java{try/catch} 
ou par le /runtime/ de l'environnement d'exception), une exception est
donc un exemple d'effet.

Observons un exemple. Voici un programme qui permet d'afficher (de manière
un peu vétuste) une liste des /Meilleurs scores/ d'un jeu quelconque:

#+BEGIN_SRC kotlin :data-roe-kind code :data-pellet Kotlin :data-line-number true :data-hl 2;5;9;12
fun displayScore() {
   println("Score\tUser\tDate")
   val scores = 
      scoreRepository
        .findAll()
        .sortBy { it.scoreValue }

   if(scores.isEmpty()) {
     throw EmptyScoreException()
   }
   scores.forEach {
      println("${it.scoreValue}\t${it.username}\t${it.date}")
   }
}
#+END_SRC

Concrètement, l'usage des fonctions src_kotlin{println} doivent se référer
au système d'exploitation pour être exécutés (en général, ce genre de fonctions,
qui écrivent sur la sortie standard ou qui lisent sur l'entrée standard 
exécutent des effets dans le domaine de l'*IO*). La méthode src_kotlin{findAll}
sur src_kotlin{scoreRepository} se référe à une base de données et le 
lancement de l'exception src_kotlin{EmptyScoreException} devra se référer
au gestionnaire que l'on écrira pour elle dans la fonction qui utilisera
src_kotlin{displayScore}.

Dans cette fonction, nous observons 3 effets différents. Une intuition viable
pour savoir si une fonction produit des effets consiste en général à se demander
si la fonction doit se référer à une autorité centrale externe à la fonction.
Et c'est généralement la présence de cette autorité centrale externe qui rend
l'implémentation d'un test unitaire complexe.

*** Les effets de bord

Maintenant que nous avons une idée (un peu abstraite) de ce qu'est un effet, 
tâchons de définir un effet de bord. Ma prise de position pourrait être un
poil polémique parce que la définition que l'on pourrait attacher à un effet
de bord peut énormément varier en fonction du contexte. Il arrive souvent
de lire le raccourci qu'un effet est un effet de bord. Pour ma part, je préfère
distinguer l'effet de l'effet de bord en donnant une définition assez naïve
mais, à mon sens, compréhensible, adaptée à la programmation statiquement
typée : *un effet de bord est un effet qui n'est pas reflété dans la signature*
*de type de la fonction qui l'exécute*.

Un exemple assez explicite pour saisir la nuance entre un effet et un effet
de bord est la fonction src_kotlin{println} dont le type pourrait être 
src_kotlin{println(x: String) : Unit}. En lisant la signature de type de
cette fonction, on a très peu d'information sur ce que *fait* la fonction.
On pourrait croire qu'elle "prend une chaine de caractères" et "n'en fait
rien". Même si le nom de la fonction peut nous transmettre une intuition
assez précise sur "ce que fait réellement la fonction", la signature de type
n'est pas suffisante. 

On voudrait (idéalement)  que toute nos signatures nous offrent la
clareté de la signature de src_kotlin{map}, par exemple : 
src_kotlin{List<A>.map(f : (A) -> B) : List<B>} (qui exprime assez clairement
que, l'application de la méthode src_kotlin{map} sur une liste de 
src_kotlin{A} avec une fonction qui va de src_kotlin{A} vers src_kotlin{B},
produira une liste de src_kotlin{B}, donc que l'on va appliquer la fonction
donnée en argument sur tous les éléments de la liste).

Un autre exemple serait la distinction entre l'utilisation d'exceptions
vérifiées contre l'utilisation d'exceptions non vérifiées. Par exemple,
voici l'implémentation, en Java, suivi d'en Kotlin, d'une fonction qui
mime l'implémentation d'une division :

#+BEGIN_SRC java :data-roe-kind code :data-pellet Java :data-line-number true
public int divide(numerator: int, denominator: int) 
   throws DivisionByZeroException {
   if (denominator == 0) {
      throw new DivisionByZeroException();
   }
   return numerator / denominator;
}
#+END_SRC

Ici, l'exception que la fonction peut émettre est reflétée dans la signature
de type. En Kotlin, on écrit généralement des fonctions qui émettent des
exceptions non vérifiées :

#+BEGIN_SRC kotlin :data-roe-kind code :data-pellet Kotlin :data-line-number true
fun divide(numerator: Int, denominator: Int) : Int {
   if (denominator == 0) {
     throw DivisionByZeroException()
   }
   return numerator / denominator
}
#+END_SRC

Dans cet exemple, la signature de type ne reflète pas l'exception pouvant être
émise par la fonction. Par contre, je ne fais pas l'apologie des exceptions
vérifiées qui [[http://radio-weblogs.com/0122027/stories/2003/04/01/JavasCheckedExceptionsWereAMistake.html][posent beaucoup de soucis]] (pour beaucoup de raisons). De plus,
les exceptions vérifiées ne couvrent le reflet que d'un seul type d'effets
(l'exception) et l'on voudrait plus de précision.

Certains pourraient voir, en cette envie de refléter les effets dans 
la signature de type, de l'hystérie de fanatiques des systèmes de types...
c'est probable. Mon opinion est que l'on voudrait que nos systèmes de types
expriment le plus de choses possibles, dans la mesure de la /turing-complétude/
(mais pas toujours). De ce fait, mettre en lumière les effets dans la signature
de types permet de transformer des effets de bord en effets, ce qui est à
mon sens bénéfique. Les fonctions ne mentiront plus sur ce qu'elles font !

Plus formellement, dans beaucoup de langages statiquement typés : 
- on propose *src_haskell{Γ ⊢ e : τ}* soit "/une variable dans l'environnement/
  /src_haskell{Γ}, une expression src_haskell{e} à le type src_haskell{τ}/".
- on voudrait *src_haskell{Γ ⊢ e : τ & effects}* soit "/une variable dans/
  /l'environnement src_haskell{Γ}, une expression src_haskell{e} à le/
  /type src_haskell{τ} et produit les effets src_haskell{effects}/".

Ce qui donnerait, par exemple, pour une fonction dont le rôle serait
d'écrire sur la sortie standard un message et qui a généralement le type 
src_ocaml{val print_string : string -> unit}, nous aurions plutôt cette
signature src_ocaml{val print_string : string -> unit & output}, ce qui
correspond à dire, au travers de la signature de type que même si la 
fonction ne renvoie rien, elle écrit aussi sur la sortie standard.
 
Pour résumer, un effet de bord est un effet qui n'est pas mis en lumière
dans le programme, qui arrive donc de manière non contrôlé et que l'on
voudrait éviter (dans la mesure du possible, il existe des effets que
l'on ne peut pas du tout contrôler dans le programme, par exemple, si
l'ordinateur qui l'exécute n'a plus assez de mémoire pour exécuter le
programme). Une manière d'informer l'utilisateur ou l'utilisatrice qu'une
fonction produit un effet serait de faire refléter les effets produits par
une fonction dans sa signature de type. Les systèmes d'effets répondent
en grande partie à ce genre problèmes et c'est ce que nous tâcherons de
découvrir dans les rubriques suivantes !

** Transformation de fonctions impures en fonctions pures

Maintenant que nous avons une idée globale de ce qu'est un effet, de ce que 
sont les fonctions pures et impures, nous allons pouvoir observer une première
technique de "contrôle des effets" qui consiste /simplement/ à transformer
une fonction impure en fonction pure.

Lorsque nous avons tâché de définir une fonction pure, on a évoqué le fait
qu'une fonction devait être *totale*, soit que pour tout paramètre, elle doit
avoir un résultat. Comme toute fonction qui n'est pas pure est impure, une
fonction qui n'est pas totale est impure, donc on pourrait considérer que
la non-totalité d'une fonction est un effet. De ce fait, prendre une fonction
non-totale et la rendre totale serait une forme de gestion d'effet. Prenons
par exemple la fonction OCaml src_ocaml{List.hd} qui prend une liste et 
renvoie sa tête (son premier élément) et dont le type serait 
src_ocaml{val hd : 'a list -> 'a} :

#+BEGIN_SRC ocaml :data-roe-kind code :data-pellet OCaml :data-line-number true
let hd list = 
  match list with 
  | [] -> failwith "List.hd empty list"
  | x :: _ -> x
#+END_SRC

Concrètement, le type de cette fonction nous dit "pour une liste de 
src_ocaml{'a} (donc de "quelque chose"), je renvoie un élément src_ocaml{'a}.
Cette fonction n'est pas totale car il existe, ici, un cas pour lequel il
n'existe pas de valeur possible. Le cas où la liste est vide, et qui engendre
le lancement d'une exception.

Pour rendre cette fonction totale, il suffit de trouver un nouveau type
capable de représenter l'ensemble des valeurs possibles. Les langages 
fonctionnels statiquement typés ont popularisé l'utilisation d'un type
spécifique qui permet de représenter la dijonction entre la présence de valeur
ou son absence : 


#+BEGIN_SRC ocaml :data-roe-kind code :data-pellet OCaml :data-line-number true
type 'a option = 
  | Some of 'a 
  | None

let hd list = 
  match list with 
  | [] -> None
  | x :: _ -> Some x
#+END_SRC

Concrètement, le type src_ocaml{'a option} (qui exprime "/une option de 
quelque chose/") et défini deux constructeurs : 

- src_ocaml{Some x} pour représenter la présence d'une valeur ; 
- src_ocaml{None} pour représenter l'absence de valeur.

L'utilisation du type src_ocaml{option} (qui s'appelle src_haskell{Maybe} en
Haskell) altère le type de notre fonction, qui devient : 
src_ocaml{val hd : 'a list -> 'a option} et rend notre fonction *totale*.
Puisque src_ocaml{None} étant une valeur admissible 
(de type src_ocaml{'a option}).

Même si cette transformation semble anodine, nous avons transformé une fonction
impure en fonction pure. Cependant, le changement de type change sensiblement
la sémantique de la fonction src_ocaml{hd}. De ce fait, si l'on veut exécuter
un programme qui utilise notre nouvelle fonction src_ocaml{hd}, il faudra
*gérer manuellement le cas où nous n'avons pas de valeur*. 

Construisons un programme qui affiche, sur la sortie standard, un message 
de bienvenue au premier prénom d'une liste de prénoms :


#+BEGIN_SRC ocaml :data-roe-kind code :data-pellet OCaml :data-line-number true :data-line-start 9
let () = 
  match hd ["Xavier"; "Nicolas"] with 
  | None -> Format.printf "Hello anonymous !"
  | Some user -> Format.printf "Hello %s !" user
#+END_SRC

A ce stade, notre fonction src_ocaml{hd} à beau être pure, notre exécution
ne l'est pas. Cependant, cela se rapproche de ce que l'on a esquissé en
début d'article, la séparation entre *la partie pure* et *la partie impure*.
Concrètement, on a *un programme*, dont le rôle est de décrire les opérations, 
et un *gestionnaire de programme* dont le rôle est d'exécuter la description
du programme.

C'est typiquement ce genre de transformation qu'utilise le langage *Haskell*
pour ne permettre la manipulation que de fonctions pures.

*** Aparté sur Haskell

Quand on se rend sur le [[https://haskell.org][site web de Haskell]], on peut y lire que Haskell est
un langage de programmation fonctionnelle pure avancé.

#+ATTR_HTML: :data-roe-kind quote
#+ATTR_HTML: :data-where https://haskell.org
#+BEGIN_roe
An advanced, *purely* functional programming language
#+END_roe

Haskell est l'archétype du langage fonctionnel pur, qui fait intensivement
usage de la technique présenté dans la rubrique précédente qui vise à
transformer les effets en valeurs. Cependant, contrairement à l'exemple que
nous avons présenté, le langage interdit les effets de bords, y comprit
dans la fonction qui va *interpréter* une fonction produisant un effet. Pour
comprendre où la magie opère, observons un "Hello World" en Haskell.

#+BEGIN_SRC haskell :data-roe-kind code :data-pellet Haskell :data-line-number true
main :: IO ()
main = 
  putStrLn "Hello World!"
#+END_SRC

Ici, src_haskell{main} est une valeur de type src_haskell{IO ()}, on peut donc
deviner le type de la fonction src_haskell{putStrLn} : 
src_haskell{putStrLn :: String -> IO ()}. En fait, src_haskell{main} est une
fonction qui ne produit aucun effet, il s'agit simplement d'une variable de 
type src_haskell{IO ()} ne *faisant rien*, comme l'indique le site web de 
Haskell sur sa page d'accueil (rubrique *Purely functional*) :


#+ATTR_HTML: :data-roe-kind quote
#+ATTR_HTML: :data-where https://haskell.org
#+BEGIN_roe
Every function in Haskell is a function in the *mathematical* sense 
(i.e., "pure"). Even side-effecting IO operations are but a *description*
of what to do, produced by *pure* code. There are no statements or 
instructions, only expressions which cannot mutate variables 
(local or global) nor access state like time or random numbers.
#+END_roe


Cette explication met en lumière quelque chose d'assez important. En Haskell,
on n'écrit pas de programme "qui fait quelque chose", on *écrit des*
*descriptions de programmes*. En compilant un programme, on vérifie statiquement
la cohérence des types, et ensuite on attache la description du programme au
/runtime/ Haskell, et ce sera lui qui exécutera les effets. Cette approche 
permet la *séparation systématique* entre la partie pure et
la partie impure du programme, ce que l'on cherche à faire depuis le
début de cet article et le fait de déléguer au /runtime/ ! Le programme
devient donc facilement testable, et il délègue à une pièce logicielle
éprouvée et correctement testée l'exécution d'effets.

Plus formellement, l'ensemble des effets communs auquel on fait face quand
on construit un logiciel est transformé en valeurs, il existe des valeurs
intermédiaires, par exemple : 

- src_haskell{List a} pour le non-déterminisme ;
- src_haskell{Maybe a} pour l'absence potentielle de valeur ; 
- src_haskell{Either error a} pour l'équivalent des exceptions ;
- src_haskell{IO a} pour les entrées sorties ;
- et bien d'autres.

Et l'objectif du développeur est de réduire ces représentations jusqu'à un 
src_haskell{IO ()} qui correspondra à la description finale du programme et
qui sera interprétée par le /runtime/ Haskell. En complément de cette
fragmentation systématique entre les fragments pures et impures du programme,
Haskell permet de refléter dans la signature de type l'effet que produira une
fonction. Pour y arriver, Haskell utilise son système de type, sans y apporter
de modification, donc src_haskell{unit & io} s'écrirait, en Haskell 
src_haskell{IO ()}, src_haskell{()} voulant dire src_haskell{unit} en Haskell.

*** Style directe et indirecte
